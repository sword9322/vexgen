// ============================================================
// VoxPrompt – Deterministic Prompt Formatter
// Produces consistent, high-quality markdown prompts without
// calling any external AI API.
// ============================================================
import type { ExtractedData, GenerateOptions, ModelTarget, Verbosity } from '@/types';
import { TEMPLATES } from './templates';

// ────────────────────────────────────────────────────────────
// Public entry point
// ────────────────────────────────────────────────────────────

/**
 * Build a structured markdown prompt from extracted data + user options.
 * This is the deterministic fallback used when the OpenAI API is unavailable.
 */
export function buildPrompt(
  transcript: string,
  extracted: ExtractedData,
  options: GenerateOptions
): string {
  const tpl = TEMPLATES[options.template];
  const parts: string[] = [];

  // ── Header ──
  parts.push(`# ${tpl.name} Prompt`);
  parts.push('');
  parts.push(tpl.rolePreamble);
  parts.push('');
  parts.push('---');
  parts.push('');

  // ── Template body ──
  parts.push(buildBody(transcript, extracted, options));

  // ── Clarifying questions (triggered when ambiguity is high) ──
  if (extracted.ambiguityScore > 0.3 || extracted.wordCount < 25) {
    parts.push('');
    parts.push(buildClarifyingQuestions(transcript, extracted, options));
  }

  // ── Footer (detailed verbosity only) ──
  if (options.verbosity === 'detailed') {
    parts.push('');
    parts.push('---');
    parts.push(
      `> *Prompt optimised for **${modelLabel(options.modelTarget)}** · ` +
        `Verbosity: **${options.verbosity}** · ` +
        `Generated by [VoxPrompt](https://github.com/voxprompt)*`
    );
  }

  return parts.join('\n').trim();
}

// ────────────────────────────────────────────────────────────
// Template-specific section builders
// ────────────────────────────────────────────────────────────

function buildBody(
  transcript: string,
  extracted: ExtractedData,
  options: GenerateOptions
): string {
  switch (options.template) {
    case 'general':
      return buildGeneral(transcript, extracted, options.verbosity, options.modelTarget);
    case 'coding':
      return buildCoding(transcript, extracted, options.verbosity, options.modelTarget);
    case 'marketing':
      return buildMarketing(transcript, extracted, options.verbosity, options.modelTarget);
    case 'meeting':
      return buildMeeting(transcript, extracted, options.verbosity);
    case 'support':
      return buildSupport(transcript, extracted, options.verbosity);
    case 'research':
      return buildResearch(transcript, extracted, options.verbosity);
  }
}

// ── General Assistant ──────────────────────────────────────

function buildGeneral(
  transcript: string,
  extracted: ExtractedData,
  verbosity: Verbosity,
  model: ModelTarget
): string {
  const sections: string[] = [];

  sections.push(section('Goal', inferGoal(transcript, extracted)));

  if (verbosity !== 'short') {
    sections.push(section('Context', inferContext(transcript, extracted)));
  }

  if (extracted.constraints.length > 0) {
    sections.push(
      section('Constraints', extracted.constraints.map((c) => `- ${c}`).join('\n'))
    );
  }

  sections.push(section('Expected Output', inferOutput(transcript, extracted)));

  if (verbosity === 'detailed') {
    sections.push(
      section(
        'Tone & Style',
        `Maintain a ${toneFromTopics(extracted.topics)} tone throughout. ` +
          `${modelSpecificTone(model)}`
      )
    );
    sections.push(
      section(
        'Success Criteria',
        [
          '- The response directly addresses the stated goal',
          `- The output is ${verbosityExpectation(verbosity)}`,
          extracted.constraints.length > 0
            ? '- All constraints listed above are respected'
            : '- The response is accurate and actionable',
          extracted.entities.length > 0
            ? `- Any references to ${extracted.entities.slice(0, 3).join(', ')} are handled correctly`
            : '',
        ]
          .filter(Boolean)
          .join('\n')
      )
    );
  }

  return sections.join('\n\n');
}

// ── Coding Task ────────────────────────────────────────────

function buildCoding(
  transcript: string,
  extracted: ExtractedData,
  verbosity: Verbosity,
  model: ModelTarget
): string {
  const sections: string[] = [];
  const isTech = extracted.topics.includes('technology');

  sections.push(section('Goal', inferGoal(transcript, extracted)));

  sections.push(
    section(
      'Technical Context',
      [
        inferContext(transcript, extracted),
        isTech
          ? `*Detected technical entities: ${extracted.entities.slice(0, 5).join(', ') || 'none identified'}*`
          : '',
      ]
        .filter(Boolean)
        .join('\n')
    )
  );

  sections.push(
    section(
      'Requirements & Constraints',
      extracted.constraints.length > 0
        ? extracted.constraints.map((c) => `- ${c}`).join('\n')
        : '- Follow standard best practices for the chosen language/framework\n- Write clean, readable, well-commented code\n- Handle edge cases and errors appropriately'
    )
  );

  if (verbosity !== 'short') {
    sections.push(
      section(
        'Input / Output Specification',
        `Based on the transcript, the function/module should:\n` +
          `- **Input**: ${inferInput(transcript, extracted)}\n` +
          `- **Output**: ${inferOutput(transcript, extracted)}`
      )
    );
  }

  if (verbosity === 'detailed') {
    sections.push(
      section(
        'Code Style & Standards',
        [
          `- Use ${model === 'claude' ? 'idiomatic' : 'standard'} patterns for the chosen language`,
          '- Include inline comments for non-obvious logic',
          '- Follow SOLID principles where applicable',
          '- Write or describe unit tests for key functionality',
        ].join('\n')
      )
    );
    sections.push(
      section(
        'Success Criteria',
        [
          '- The code compiles/runs without errors',
          '- All specified requirements are met',
          '- Edge cases are handled gracefully',
          '- The solution is performant and maintainable',
        ].join('\n')
      )
    );
  }

  return sections.join('\n\n');
}

// ── Marketing Copy ─────────────────────────────────────────

function buildMarketing(
  transcript: string,
  extracted: ExtractedData,
  verbosity: Verbosity,
  _model: ModelTarget
): string {
  const sections: string[] = [];

  sections.push(section('Campaign Goal', inferGoal(transcript, extracted)));
  sections.push(
    section(
      'Target Audience',
      `Based on the transcript: ${inferContext(transcript, extracted)}\n\n` +
        `*Identify the primary audience segment, their pain points, and what motivates them.*`
    )
  );
  sections.push(
    section(
      'Brand Voice & Tone',
      `${toneFromTopics(extracted.topics, 'marketing')}. ` +
        `Reflect the personality of the brand while remaining authentic to the audience.`
    )
  );

  if (verbosity !== 'short') {
    sections.push(
      section(
        'Key Messages',
        '- **Primary**: ' + inferGoal(transcript, extracted) + '\n' +
          (extracted.entities.length > 0
            ? `- **Secondary**: Highlight ${extracted.entities.slice(0, 2).join(' and ')}\n`
            : '') +
          '- **Call-to-action**: [Specify the desired action]'
      )
    );
  }

  sections.push(
    section(
      'Format & Constraints',
      extracted.constraints.length > 0
        ? extracted.constraints.map((c) => `- ${c}`).join('\n')
        : '- Specify channel (e.g. email, social post, landing page)\n- Word/character limit as needed\n- Any brand guidelines to follow'
    )
  );

  if (verbosity === 'detailed') {
    sections.push(
      section(
        'Success Metrics',
        [
          '- The copy resonates with the identified target audience',
          '- The key messages are clear and compelling',
          '- The tone matches the brand voice',
          '- The call-to-action is specific and motivating',
        ].join('\n')
      )
    );
  }

  return sections.join('\n\n');
}

// ── Meeting → Action Plan ──────────────────────────────────

function buildMeeting(
  transcript: string,
  extracted: ExtractedData,
  verbosity: Verbosity
): string {
  const sections: string[] = [];

  sections.push(
    section(
      'Meeting Overview',
      `**Raw notes:**\n> ${truncate(transcript, 600)}\n\n` +
        `*Please extract and structure the information below from these notes.*`
    )
  );

  sections.push(
    section(
      'Key Decisions Made',
      `Identify and list all decisions reached during this meeting.\n` +
        (extracted.entities.length > 0
          ? `\nParticipants / teams mentioned: ${extracted.entities.join(', ')}`
          : '')
    )
  );

  sections.push(
    section(
      'Action Items',
      `List every action item in the format:\n` +
        `- [ ] **[Owner]** – [Task description] – *Due: [Date/Timeline]*\n\n` +
        `If not explicitly mentioned, mark owner as [TBD].`
    )
  );

  if (verbosity !== 'short') {
    sections.push(
      section(
        'Follow-up Required',
        `List topics that were raised but not resolved, and require further discussion or input.`
      )
    );
  }

  if (verbosity === 'detailed') {
    sections.push(
      section(
        'Risks & Blockers',
        `Identify any concerns, dependencies, or blockers mentioned during the meeting.`
      )
    );
    sections.push(
      section(
        'Next Meeting',
        `Proposed agenda items and timing for the next meeting, if discussed.`
      )
    );
  }

  return sections.join('\n\n');
}

// ── Support → Troubleshooting ──────────────────────────────

function buildSupport(
  transcript: string,
  extracted: ExtractedData,
  verbosity: Verbosity
): string {
  const sections: string[] = [];

  sections.push(
    section(
      'Issue Description',
      `**Reported issue:**\n> ${truncate(transcript, 500)}`
    )
  );

  sections.push(
    section(
      'Environment & Context',
      [
        extracted.entities.length > 0
          ? `**Systems/components mentioned:** ${extracted.entities.join(', ')}`
          : '**System:** [Specify OS, browser, version, environment]',
        '**Configuration:** [Relevant config details]',
        '**When did this start?** [Timeline]',
      ].join('\n')
    )
  );

  sections.push(
    section(
      'Expected vs. Actual Behaviour',
      `- **Expected:** [What should happen]\n` +
        `- **Actual:** [What is happening instead]\n` +
        `- **Error messages:** [Paste any errors or logs]`
    )
  );

  if (verbosity !== 'short') {
    sections.push(
      section(
        'Steps Already Tried',
        extracted.constraints.length > 0
          ? extracted.constraints.map((c) => `- ${c}`).join('\n')
          : '- [List any troubleshooting steps already attempted]'
      )
    );
  }

  sections.push(
    section(
      'Urgency & Impact',
      `- **Severity:** [Critical / High / Medium / Low]\n` +
        `- **Affected users/systems:** [Who is impacted]\n` +
        `- **Business impact:** [Describe the effect on operations]`
    )
  );

  if (verbosity === 'detailed') {
    sections.push(
      section(
        'Desired Resolution',
        `Provide step-by-step troubleshooting instructions to diagnose and resolve this issue. ` +
          `Include rollback steps if applicable.`
      )
    );
  }

  return sections.join('\n\n');
}

// ── Research Brief ─────────────────────────────────────────

function buildResearch(
  transcript: string,
  extracted: ExtractedData,
  verbosity: Verbosity
): string {
  const sections: string[] = [];

  sections.push(section('Research Question', inferGoal(transcript, extracted)));

  if (verbosity !== 'short') {
    sections.push(
      section(
        'Background',
        `What is already known or established in this area:\n` +
          `${inferContext(transcript, extracted)}\n\n` +
          (extracted.entities.length > 0
            ? `*Key entities identified: ${extracted.entities.join(', ')}*`
            : '*No specific entities detected — please provide relevant context.*')
      )
    );
  }

  sections.push(
    section(
      'Scope & Boundaries',
      [
        '**In scope:**',
        '- ' + (extracted.topics.map((t) => `Research related to ${t}`).join('\n- ') || '[Specify scope]'),
        '',
        '**Out of scope:**',
        extracted.constraints.length > 0
          ? extracted.constraints.map((c) => `- ${c}`).join('\n')
          : '- [Specify exclusions]',
      ].join('\n')
    )
  );

  if (verbosity !== 'short') {
    sections.push(
      section(
        'Methodology',
        `Suggested approach for conducting this research:\n` +
          `- Literature review / secondary research\n` +
          `- Data sources to consult: [academic, industry, government, etc.]\n` +
          `- Analysis framework: [comparative, qualitative, quantitative]`
      )
    );
  }

  sections.push(
    section(
      'Expected Deliverables',
      `- A structured ${inferOutput(transcript, extracted)} covering the research question\n` +
        `- Key findings with supporting evidence\n` +
        `- Conclusions and recommendations\n` +
        `- References / sources cited`
    )
  );

  if (verbosity === 'detailed') {
    sections.push(
      section(
        'Success Criteria',
        [
          '- The research question is answered comprehensively',
          '- Claims are backed by credible sources',
          '- Findings are clearly summarised with actionable insights',
          '- Limitations and gaps are acknowledged',
        ].join('\n')
      )
    );
  }

  return sections.join('\n\n');
}

// ────────────────────────────────────────────────────────────
// Clarifying questions
// ────────────────────────────────────────────────────────────

function buildClarifyingQuestions(
  transcript: string,
  extracted: ExtractedData,
  options: GenerateOptions
): string {
  const questions: string[] = [];

  if (extracted.wordCount < 25) {
    questions.push('- Could you provide more context about what you are trying to achieve?');
  }

  if (extracted.primaryIntent === 'general') {
    questions.push('- What is the primary action or deliverable you are expecting?');
  }

  if (extracted.outputType === 'response') {
    questions.push('- What format should the output take? (e.g. list, document, code, email)');
  }

  if (extracted.entities.length === 0) {
    questions.push(
      '- Are there specific people, systems, tools, or organisations that should be referenced?'
    );
  }

  if (extracted.constraints.length === 0) {
    questions.push(
      '- Are there any constraints, limitations, or requirements to keep in mind?'
    );
  }

  if (
    options.template === 'coding' &&
    !extracted.topics.includes('technology')
  ) {
    questions.push(
      '- Which programming language, framework, or platform should be used?'
    );
  }

  if (options.template === 'marketing' && extracted.ambiguityScore > 0.4) {
    questions.push('- Who is the target audience, and on which channel will this appear?');
  }

  if (questions.length === 0) {
    questions.push('- Is there any additional context that would help refine the output?');
  }

  return (
    `## Clarifying Questions\n\n` +
    `*The transcript left some aspects open. Answering these will improve the generated output:*\n\n` +
    questions.join('\n')
  );
}

// ────────────────────────────────────────────────────────────
// Inference helpers
// ────────────────────────────────────────────────────────────

function inferGoal(transcript: string, extracted: ExtractedData): string {
  const intent = extracted.primaryIntent;
  const output = extracted.outputType;
  const base = truncate(transcript, 200).replace(/\n+/g, ' ');

  if (intent !== 'general' && output !== 'response') {
    return `${capitalise(intent)} a ${output} that accomplishes the following:\n\n> "${base}"`;
  }
  return `Based on the following voice note, please complete the task described:\n\n> "${base}"`;
}

function inferContext(transcript: string, extracted: ExtractedData): string {
  const topicList =
    extracted.topics.length > 0
      ? `This request is in the domain of: **${extracted.topics.join(', ')}**.`
      : '';
  const entityList =
    extracted.entities.length > 0
      ? `\nKey entities mentioned: ${extracted.entities.join(', ')}.`
      : '';
  return [topicList, entityList].filter(Boolean).join('') || 'No specific context detected from the transcript.';
}

function inferInput(_transcript: string, extracted: ExtractedData): string {
  if (extracted.entities.length > 0) {
    return extracted.entities.slice(0, 3).join(', ');
  }
  return '[Specify input parameters or data]';
}

function inferOutput(transcript: string, extracted: ExtractedData): string {
  const typeMap: Record<string, string> = {
    code: 'Working, well-documented code',
    list: 'A structured, prioritised list',
    document: 'A clear, well-structured document',
    email: 'A professional, ready-to-send email',
    analysis: 'A detailed analysis with findings and recommendations',
    plan: 'A step-by-step action plan with owners and timelines',
    presentation: 'A presentation outline with key slides',
    response: 'A clear, helpful response',
  };
  return typeMap[extracted.outputType] ?? 'A clear, actionable response';
}

// ────────────────────────────────────────────────────────────
// Utility helpers
// ────────────────────────────────────────────────────────────

function section(title: string, body: string): string {
  return `## ${title}\n\n${body}`;
}

function truncate(text: string, maxChars: number): string {
  if (text.length <= maxChars) return text;
  return text.slice(0, maxChars).replace(/\s+\S*$/, '') + '…';
}

function capitalise(s: string): string {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

function modelLabel(model: ModelTarget): string {
  return { claude: 'Claude', chatgpt: 'ChatGPT', universal: 'Universal' }[model];
}

function verbosityExpectation(verbosity: Verbosity): string {
  return {
    short: 'concise and to the point',
    medium: 'well-balanced in detail and brevity',
    detailed: 'comprehensive and thorough',
  }[verbosity];
}

function toneFromTopics(topics: string[], override?: string): string {
  if (override === 'marketing') return 'persuasive, engaging, and brand-appropriate';
  if (topics.includes('technology')) return 'technical yet accessible';
  if (topics.includes('business')) return 'professional and results-oriented';
  if (topics.includes('research')) return 'objective and evidence-based';
  if (topics.includes('support')) return 'empathetic and solution-focused';
  return 'clear and professional';
}

function modelSpecificTone(model: ModelTarget): string {
  return {
    claude: 'Structure responses using XML tags where it aids clarity.',
    chatgpt: 'Use numbered lists and explicit headings for easy parsing.',
    universal: 'Use standard Markdown formatting for universal compatibility.',
  }[model];
}
